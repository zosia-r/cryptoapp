import os
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography import exceptions

# Second salt needed
# Is randomly generated
# TODO change?
# derive key from password
# pwd: given pwd
# TODO at the moment: key is derived from whole password
# TODO later: key should be derived from the pwd token
def derive_key(pwd):
    salt = os.urandom(16)
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=1_200_000,
    )
    key = kdf.derive(pwd)
    return salt, key

# Verifies if the given pwd matches the stored pwd of the given username
# pwd: given pwd
# key: the stored key to the corresponding, given username
# No return type needed, it raises an exception if it does not match
# TODO probably handle exception 
def verify_key(pwd, salt, key):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=1_200_000,
    )
    kdf.verify(pwd, key)


def test():
    pwd = b"password"
    wrong_pwd = b"asfi"
    salt, key = derive_key(pwd)
    print("Salt and key were derived")
    try:
        verify_key(pwd, salt, key)
    except exceptions.InvalidKey:
        print("Can't be divided by zero!")
    print("Pwd was successfully verified, the pwd is right.")
    try:
        verify_key(wrong_pwd, salt, key)
    except exceptions.InvalidKey:
        print("Exception: Keys do not match")